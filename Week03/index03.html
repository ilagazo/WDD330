<!doctype html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"
    integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
  <!-- <link rel="stylesheet" href="../WDD330/css/main.css"> -->
  <link rel="stylesheet" type="text/css" href="https://ilagazo.github.io/WDD330/css/notes.css">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@900&display=swap" rel="stylesheet">
  <title>Week 03 Notes</title>
</head>

<body>
  <header>
    <h1>Week 03 Notes</h1>
  </header>
  <!-- Option 1: jQuery and Bootstrap Bundle (includes Popper) -->
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
    integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
    crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx"
    crossorigin="anonymous"></script>

  <div class="notes">
    <h2>JavaScript: Novice to Ninja, 2nd Edition & "THIS"</h2>
    <div class="notes-sub">
      <h3>Object methods, "this"</h3>
      <ul>
        <li>A function that is a property of an object is called its method.</li>
        <li>When we write our code using objects to represent entities, that’s called object-oriented programming, in
          short: “OOP”.</li>
        <li>Shorthand Notation: // method shorthand looks better, right?
          user = {
          sayHi() { // same as "sayHi: function(){...}"
          alert("Hello");
          }
          };</li>
        <li>It’s common that an object method needs to access the information stored in the object to do its job.
          For instance, the code inside user.sayHi() may need the name of the user.
          To access the object, a method can use the this keyword.</li>
        <li>THIS is not bound.In JavaScript, keyword this behaves unlike most other programming languages. It can be
          used in any function, even if it’s not a method of an object. </li>
        <li>The value of this is defined at run-time.
          When a function is declared, it may use this, but that this has no value until the function is called.
          A function can be copied between objects.
          When a function is called in the “method” syntax: object.method(), the value of this during the call is
          object.</li>
        <li></li>
      </ul>
    </div>
    <div class="notes-sub">
      <h3>This in JavaScript</h3>
      <ul>
        <li>this is a keyword whose value changes depending on how a function gets called. There six different ways where this can take on new values. </li>
        <li>This in a global context: When this is called outside of any function, in a global context, this defaults to the Window object in the browser.</li>
        <li>This in object construction: When you create a new instance of an object with the new keyword, this refers to the instance. </li>
        <li>This in an object method: this within any method refers to the object itself. Since this refers to the object, you can use methods to get the instance of an object</li>
        <li>This in a simple function: On browsers, this is always set to Window in a simple function.</li>
        <li>This in arrow functions: this in an arrow function is always the same as this around it (in its immediate scope). So, if you use arrow functions within an object method, the this context stays as the object, not Window.</li>
        <li>This in event listeners: this is set to the element that fired the event in an event listener</li>
      </ul>
    </div>
    <div class="notes-sub">
      <h3>Ch5: Objects</h3>
      <ul>
        <li>An object in JavaScript is a self-contained set of related values and functions.</li>
        <li>Object Literal: An object literal is an object that is created directly in the language by wrapping all its properties and methods in curly braces {} </li>
        <li>Use const functionName = {} OR const functionName = new Object() to create an object literal. The second way creates an empty object.</li>
        <li>You can access the properties of an object using the dot notation.</li>
        <li>You can also access an object’s properties using bracket notation ― the property is represented by a string inside square brackets, so needs to be placed inside single or double quotation marks:superman['name']</li>
        <li>To call an object’s method we can also use dot or bracket notation. Calling a method is the same as invoking a function, so parentheses need to be placed after the method name</li>
        <li>SON is a string representation of the object literal notation that we have just seen. There are, however, a couple of key differences:</li>
         <li>1. Property names must be double-quoted</li> 
          <li>2. Permitted values are double-quoted strings, numbers, true, false, null, arrays and objects</li>
         <li>3. Functions are not permitted values</li>
      </ul>
    </div>
    <div class="notes-sub">
      <h3>Ch6: Document Object Model</h3>
      <ul>
        <li>The Document Object Model, or DOM for short, represents an HTML document as a network of connected nodes that form a tree-like structure.</li>
        <li>The DOM treats everything on a web page as a node. HTML tags, the text inside these tags, even the attributes of a tag are all nodes. The HTML tag is the root node, and every other part of the document is a child node of this.</li>
        <li>The DOM provides several methods that allow us to access any element on a page. These methods will return a node object or a node list, which is an array-like object. These objects can then be assigned to a variable and be inspected or modified.</li>
        <li>All nodes have a numerical code to signify what type they are. (i.e. 1 = element, 2 = attribute, etc.</li>
        <li>We can access elements by their tag or class name</li>
        <li>The document.querySelector() method allows you to use CSS notation to find thefirstelement in the document that matches that matches a CSS selector provided as an argument. If no elements match, it will return null .</li>
        <li>CSS query selectors are a powerful way of specifying very precise items on a page.</li>'
        <li>jQuery is a popular JavaScript framework that makes it very easy to find elements on a page using a CSS-style syntax. </li>
        <li>Use nodeValue and textContent to find the value of text in a tag</li>
      </ul>
    </div>
    <div class="notes-sub">
      <h3>Ch7: Events</h3>
      <ul>
        <li>When using events, callback functions are usally used to ensure any other code runs while an event is listened to</li>
        <li>There are a variety of ways to find the position of where a mouse event occurs.The screenX and screenY properties show the number of pixels from the left and top of the screen respectively where the event took place.
          The clientX and clientY properties show the number of pixels from the left and top of the client that is being used (usually the browser window).The pageX and pageY properties show the number of pixels from the left and top, 
          respectively, where the event took place in thedocument. This property takes account of whether the page has been scrolled.</li>
        <li>Events are used to track when a user clicks, scrolls, keys down or up, etc.</li>
        <li>Event Propagation: When you click on an element, you are actually clicking on all the elements it’s nested inside of. For example, clicking an li tag will also click the ul, body, and html tags as well.</li>
        <li>Two forms of event propagation: bubbling and capturing.</li>
        <li>Bubbling: Bubbling is when the event fires on the element clicked on first, then bubbles up the document tree, firing an event on each parent element until it reaches the root node.</li>
        <li>Capturing: Capturing starts by firing an event on the root element, then propagates downwards, firing an event on each child element until it reaches the target element that was clicked on.</li>
        <li>The addEventListener() method has a third parameter, which is a boolean value that specifies whether capturing should be used or not. It defaults to false , which is why bubbling happens by default. 
          There may be instances when you would rather capture the events instead; for example, you might want events on outer elements to fire before any events fire on the element that was actually clicked on.</li>
        <li>The bubble phase can be stopped from occurring by adding the event.stopPropagation() method into the callback function. </li>
        <li>Event delegation can be used to attach an event listener to a parent element in order to capture events that are triggered by its child elements.</li>
    </div>
    <div class="notes-sub">
      <h3>Questions:</h3>
      <ul>
        <li>How can events be used for e-commerce marketing purposes?</li>
        <li>When is Capturing useful from bubbling?</li>
        <li>.value vs .nodeValue? Is there a difference?</li>
      </ul>
    </div>
  </div>
    <footer>
      <p>Professional Networking Links:</p>
      <div class="footer-links">
        <a href="https://www.linkedin.com/in/ivanro-lagazo/">LinkedIn</a>
        <a href="https://github.com/ilagazo">GitHub</a>
        <a href="../WDD330/index.html">Portfolio</a>
      </div>
    </footer>
</body>

</html>